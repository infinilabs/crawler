// Code generated by cdpgen. DO NOT EDIT.

// Package runtime implements the Runtime domain. Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.
package runtime

import (
	"context"

	"github.com/mafredri/cdp/protocol/internal"
	"github.com/mafredri/cdp/rpcc"
)

// domainClient is a client for the Runtime domain. Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.
type domainClient struct{ conn *rpcc.Conn }

// NewClient returns a client for the Runtime domain with the connection set to conn.
func NewClient(conn *rpcc.Conn) *domainClient {
	return &domainClient{conn: conn}
}

// Evaluate invokes the Runtime method. Evaluates expression on global object.
func (d *domainClient) Evaluate(ctx context.Context, args *EvaluateArgs) (reply *EvaluateReply, err error) {
	reply = new(EvaluateReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.evaluate", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.evaluate", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "Evaluate", Err: err}
	}
	return
}

// AwaitPromise invokes the Runtime method. Add handler to promise with given promise object id.
func (d *domainClient) AwaitPromise(ctx context.Context, args *AwaitPromiseArgs) (reply *AwaitPromiseReply, err error) {
	reply = new(AwaitPromiseReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.awaitPromise", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.awaitPromise", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "AwaitPromise", Err: err}
	}
	return
}

// CallFunctionOn invokes the Runtime method. Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
func (d *domainClient) CallFunctionOn(ctx context.Context, args *CallFunctionOnArgs) (reply *CallFunctionOnReply, err error) {
	reply = new(CallFunctionOnReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.callFunctionOn", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.callFunctionOn", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "CallFunctionOn", Err: err}
	}
	return
}

// GetProperties invokes the Runtime method. Returns properties of a given object. Object group of the result is inherited from the target object.
func (d *domainClient) GetProperties(ctx context.Context, args *GetPropertiesArgs) (reply *GetPropertiesReply, err error) {
	reply = new(GetPropertiesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.getProperties", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.getProperties", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "GetProperties", Err: err}
	}
	return
}

// ReleaseObject invokes the Runtime method. Releases remote object with given id.
func (d *domainClient) ReleaseObject(ctx context.Context, args *ReleaseObjectArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.releaseObject", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.releaseObject", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "ReleaseObject", Err: err}
	}
	return
}

// ReleaseObjectGroup invokes the Runtime method. Releases all remote objects that belong to a given group.
func (d *domainClient) ReleaseObjectGroup(ctx context.Context, args *ReleaseObjectGroupArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.releaseObjectGroup", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.releaseObjectGroup", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "ReleaseObjectGroup", Err: err}
	}
	return
}

// RunIfWaitingForDebugger invokes the Runtime method. Tells inspected instance to run if it was waiting for debugger to attach.
func (d *domainClient) RunIfWaitingForDebugger(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.runIfWaitingForDebugger", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "RunIfWaitingForDebugger", Err: err}
	}
	return
}

// Enable invokes the Runtime method. Enables reporting of execution contexts creation by means of executionContextCreated event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
func (d *domainClient) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.enable", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Runtime method. Disables reporting of execution contexts creation.
func (d *domainClient) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.disable", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "Disable", Err: err}
	}
	return
}

// DiscardConsoleEntries invokes the Runtime method. Discards collected exceptions and console API calls.
func (d *domainClient) DiscardConsoleEntries(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.discardConsoleEntries", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "DiscardConsoleEntries", Err: err}
	}
	return
}

// SetCustomObjectFormatterEnabled invokes the Runtime method.
func (d *domainClient) SetCustomObjectFormatterEnabled(ctx context.Context, args *SetCustomObjectFormatterEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.setCustomObjectFormatterEnabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.setCustomObjectFormatterEnabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "SetCustomObjectFormatterEnabled", Err: err}
	}
	return
}

// CompileScript invokes the Runtime method. Compiles expression.
func (d *domainClient) CompileScript(ctx context.Context, args *CompileScriptArgs) (reply *CompileScriptReply, err error) {
	reply = new(CompileScriptReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.compileScript", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.compileScript", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "CompileScript", Err: err}
	}
	return
}

// RunScript invokes the Runtime method. Runs script with given id in a given context.
func (d *domainClient) RunScript(ctx context.Context, args *RunScriptArgs) (reply *RunScriptReply, err error) {
	reply = new(RunScriptReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.runScript", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.runScript", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "RunScript", Err: err}
	}
	return
}

// QueryObjects invokes the Runtime method.
func (d *domainClient) QueryObjects(ctx context.Context, args *QueryObjectsArgs) (reply *QueryObjectsReply, err error) {
	reply = new(QueryObjectsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.queryObjects", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.queryObjects", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "QueryObjects", Err: err}
	}
	return
}

// GlobalLexicalScopeNames invokes the Runtime method. Returns all let, const and class variables from global scope.
func (d *domainClient) GlobalLexicalScopeNames(ctx context.Context, args *GlobalLexicalScopeNamesArgs) (reply *GlobalLexicalScopeNamesReply, err error) {
	reply = new(GlobalLexicalScopeNamesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.globalLexicalScopeNames", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.globalLexicalScopeNames", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "GlobalLexicalScopeNames", Err: err}
	}
	return
}

func (d *domainClient) ExecutionContextCreated(ctx context.Context) (ExecutionContextCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.executionContextCreated", d.conn)
	if err != nil {
		return nil, err
	}
	return &executionContextCreatedClient{Stream: s}, nil
}

type executionContextCreatedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *executionContextCreatedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *executionContextCreatedClient) Recv() (*ExecutionContextCreatedReply, error) {
	event := new(ExecutionContextCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExecutionContextCreated Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExecutionContextDestroyed(ctx context.Context) (ExecutionContextDestroyedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.executionContextDestroyed", d.conn)
	if err != nil {
		return nil, err
	}
	return &executionContextDestroyedClient{Stream: s}, nil
}

type executionContextDestroyedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *executionContextDestroyedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *executionContextDestroyedClient) Recv() (*ExecutionContextDestroyedReply, error) {
	event := new(ExecutionContextDestroyedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExecutionContextDestroyed Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExecutionContextsCleared(ctx context.Context) (ExecutionContextsClearedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.executionContextsCleared", d.conn)
	if err != nil {
		return nil, err
	}
	return &executionContextsClearedClient{Stream: s}, nil
}

type executionContextsClearedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *executionContextsClearedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *executionContextsClearedClient) Recv() (*ExecutionContextsClearedReply, error) {
	event := new(ExecutionContextsClearedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExecutionContextsCleared Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExceptionThrown(ctx context.Context) (ExceptionThrownClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.exceptionThrown", d.conn)
	if err != nil {
		return nil, err
	}
	return &exceptionThrownClient{Stream: s}, nil
}

type exceptionThrownClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *exceptionThrownClient) GetStream() rpcc.Stream { return c.Stream }

func (c *exceptionThrownClient) Recv() (*ExceptionThrownReply, error) {
	event := new(ExceptionThrownReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExceptionThrown Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExceptionRevoked(ctx context.Context) (ExceptionRevokedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.exceptionRevoked", d.conn)
	if err != nil {
		return nil, err
	}
	return &exceptionRevokedClient{Stream: s}, nil
}

type exceptionRevokedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *exceptionRevokedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *exceptionRevokedClient) Recv() (*ExceptionRevokedReply, error) {
	event := new(ExceptionRevokedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExceptionRevoked Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ConsoleAPICalled(ctx context.Context) (ConsoleAPICalledClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.consoleAPICalled", d.conn)
	if err != nil {
		return nil, err
	}
	return &consoleAPICalledClient{Stream: s}, nil
}

type consoleAPICalledClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *consoleAPICalledClient) GetStream() rpcc.Stream { return c.Stream }

func (c *consoleAPICalledClient) Recv() (*ConsoleAPICalledReply, error) {
	event := new(ConsoleAPICalledReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ConsoleAPICalled Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) InspectRequested(ctx context.Context) (InspectRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.inspectRequested", d.conn)
	if err != nil {
		return nil, err
	}
	return &inspectRequestedClient{Stream: s}, nil
}

type inspectRequestedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *inspectRequestedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *inspectRequestedClient) Recv() (*InspectRequestedReply, error) {
	event := new(InspectRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "InspectRequested Recv", Err: err}
	}
	return event, nil
}
